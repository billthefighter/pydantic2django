from typing import Any, TypeVar, cast, TypedDict

from django.db import models
from pydantic import BaseModel

from pydantic2django.base_django_model import Pydantic2DjangoBaseClass

# Import the original Pydantic model for type hints
from {{ module_path }} import {{ original_name }}

"""
Django model for {{ original_name }}.
"""

{% if context_fields %}
class {{ model_name }}Context(TypedDict):
    """Required context fields for converting {{ model_name }} back to {{ original_name }}."""
    {% for field in context_fields %}
    {{ field }}: Any  # TODO: Could potentially get actual type from original Pydantic model
    {% endfor %}
{% endif %}

class {{ model_name }}(Pydantic2DjangoBaseClass[{{ original_name }}]):
    """
    Django model for {{ original_name }}.
    {% if context_fields %}

    Context Fields:
        The following fields require context when converting back to Pydantic:
        {% for field in context_fields %}
        - {{ field }}
        {% endfor %}

    Example:
        ```python
        django_obj = {{ model_name }}.objects.get(...)
        context = {{ model_name }}Context.create(
            {% for field in context_fields %}
            {{ field }}=value,  # Required
            {% endfor %}
        )
        pydantic_obj = django_obj.to_pydantic(context=context)
        ```
    {% endif %}
    """

    {% for field_name, field_definition in fields %}
    {% if field_name != 'id' and field_name != 'object_type' and field_name != 'object_type_field' and not field_definition.startswith('models.BigAutoField') and not field_definition.startswith('models.UUIDField') %}
    {{ field_name }} = {{ field_definition|replace('to=\'', 'to=\''~meta.app_label~'.')|replace('default=<class \'django.db.models.fields.NOT_PROVIDED\'>', 'null=True') }}
    {% endif %}
    {% endfor %}

    class Meta(Pydantic2DjangoBaseClass.Meta):
        db_table = "{{ meta.db_table }}"
        app_label = "{{ meta.app_label }}"
        verbose_name = """{{ meta.verbose_name.split('\n')[0] }}"""
        verbose_name_plural = """{{ meta.verbose_name_plural.split('\n')[0] }}"""
        abstract = False

    def __init__(self, *args, **kwargs):
        kwargs.setdefault("object_type_field", "{{ module_path }}.{{ original_name }}")
        super().__init__(*args, **kwargs)

    {% if context_fields %}
    def to_pydantic(self, context: "{{ model_name }}Context") -> {{ original_name }}:
        """
        Convert this Django model to a Pydantic object.

        Args:
            context: Context instance containing values for non-serializable fields.
                    Required for this model because it has non-serializable fields.

        Returns:
            The corresponding {{ original_name }} object

        Raises:
            ValueError: If context is missing required fields
        """
        return cast({{ original_name }}, super().to_pydantic(context=context))
    {% endif %}
