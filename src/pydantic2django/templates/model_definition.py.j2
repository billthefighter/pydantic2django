"""
Django model for {{ original_name }}.
"""

{% set cleaned_original_name = original_name.split('[')[0] if '[' in original_name else original_name %}
class {{ model_name }}(Pydantic2DjangoBaseClass[{{ cleaned_original_name }}]):
    """
    Django model for {{ original_name }}.
    {% if context_fields %}

    Context Fields:
        The following fields require context when converting back to Pydantic:
        {% for field_name, field_type in context_fields %}
        - {{ field_name }}: {{ field_type }}
        {% endfor %}
    {% endif %}
    """

    {% for field_name, field_definition in fields %}
    {% if field_name != 'id' and field_name != 'object_type' and field_name != 'object_type_field' and not field_definition.startswith('models.BigAutoField') and not field_definition.startswith('models.UUIDField') %}
    {{ field_name }} = {{ field_definition|replace('default=<class \'django.db.models.fields.NOT_PROVIDED\'>', 'null=True') }}
    {% endif %}
    {% endfor %}

    class Meta(Pydantic2DjangoBaseClass.Meta):
        db_table = "{{ meta.db_table }}"
        app_label = "{{ meta.app_label }}"
        verbose_name = """{{ meta.verbose_name.split('\n')[0] }}"""
        verbose_name_plural = """{{ meta.verbose_name_plural.split('\n')[0] }}"""
        abstract = False

    {% if context_fields %}
    def to_pydantic(self, context: "{{ model_name }}Context") -> {{ cleaned_original_name }}:
        """
        Convert this Django model to The corresponding {{ original_name }} object.
        """
        return cast({{ cleaned_original_name }}, super().to_pydantic(context=context))
    {% endif %}
