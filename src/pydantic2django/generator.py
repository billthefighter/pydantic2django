"""
Code generation utilities for pydantic2django.

This module provides utilities for generating Django model code from converted models.
"""
import datetime
import inspect
from typing import Any, Dict, List, Optional, Type

from django.db import models

def generate_code(
    django_models: Dict[str, Type[models.Model]],
    module_path: str,
) -> str:
    """
    Generate Django model code from converted models.

    Args:
        django_models: Dictionary mapping Pydantic model names to Django model classes
        module_path: Path to the module containing the Pydantic models

    Returns:
        Generated code as a string
    """
    # Sort models by name for consistent output
    sorted_models = sorted(django_models.items(), key=lambda x: x[0])

    # Generate imports
    imports = [
        "# This file was generated by pydantic2django",
        "# Do not edit this file manually",
        f"# Generated on {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
        "",
        "from django.db import models",
        "from pydantic2django.base_django_model import Pydantic2DjangoBaseClass",
        "",
        "# Constants for default values",
        "true = True",
        "false = False",
        "# Define a proper undefined type that won't cause issues with Django",
        "class UndefinedType:",
        "    def __repr__(self):",
        "        return \"Undefined\"",
        "",
        "    def __bool__(self):",
        "        return False",
        "",
        "PydanticUndefined = UndefinedType()",
        "",
        "# Additional imports",
        "import uuid",
        "import importlib",
        "from typing import Any, Dict, List, Optional, Union",
        "",
    ]

    # Generate model code
    model_code = []
    for model_name, model_class in sorted_models:
        # Get model fields
        fields = []
        for field in model_class._meta.fields:
            field_code = f"    {field.name} = {field.__class__.__name__}("
            
            # Add field parameters
            params = []
            for key, value in field.__dict__.items():
                # Skip internal attributes and empty values
                if key.startswith("_") or value is None:
                    continue
                
                # Skip some common attributes that don't need to be specified
                if key in ["model", "creation_counter", "auto_created", "primary_key"]:
                    continue
                
                # Format the value based on its type
                if isinstance(value, str):
                    formatted_value = f"'{value}'"
                elif isinstance(value, bool):
                    formatted_value = str(value)
                elif isinstance(value, (int, float)):
                    formatted_value = str(value)
                elif value == "PydanticUndefined":
                    formatted_value = "PydanticUndefined"
                else:
                    formatted_value = str(value)
                
                params.append(f"{key}={formatted_value}")
            
            field_code += ", ".join(params) + ")"
            fields.append(field_code)
        
        # Get many-to-many fields
        for field in model_class._meta.many_to_many:
            field_code = f"    {field.name} = models.ManyToManyField("
            
            # Add field parameters
            params = []
            for key, value in field.__dict__.items():
                # Skip internal attributes and empty values
                if key.startswith("_") or value is None:
                    continue
                
                # Skip some common attributes that don't need to be specified
                if key in ["model", "creation_counter", "auto_created"]:
                    continue
                
                # Format the value based on its type
                if isinstance(value, str):
                    formatted_value = f"'{value}'"
                elif isinstance(value, bool):
                    formatted_value = str(value)
                elif isinstance(value, (int, float)):
                    formatted_value = str(value)
                elif value == "PydanticUndefined":
                    formatted_value = "PydanticUndefined"
                else:
                    formatted_value = str(value)
                
                params.append(f"{key}={formatted_value}")
            
            field_code += ", ".join(params) + ")"
            fields.append(field_code)
        
        # Get Meta class
        meta_code = ["    class Meta(Pydantic2DjangoBaseClass.Meta):"]
        for key, value in model_class._meta.__dict__.items():
            # Skip internal attributes and empty values
            if key.startswith("_") or value is None:
                continue
            
            # Skip some common attributes that don't need to be specified
            if key in ["model", "app_config", "apps", "base_manager", "default_manager", "managers"]:
                continue
            
            # Format the value based on its type
            if isinstance(value, str):
                formatted_value = f"\"{value}\""
            elif isinstance(value, bool):
                formatted_value = str(value)
            elif isinstance(value, (int, float)):
                formatted_value = str(value)
            elif isinstance(value, list):
                formatted_value = str(value)
            else:
                continue
            
            meta_code.append(f"        {key} = {formatted_value}")
        
        # Get __init__ method if it exists
        init_code = []
        if hasattr(model_class, "__init__"):
            init_method = inspect.getsource(model_class.__init__)
            # Remove the first line (def __init__) and adjust indentation
            init_lines = init_method.split("\n")[1:]
            init_code = ["    def __init__(self, *args, **kwargs):"]
            for line in init_lines:
                if line.strip():
                    # Adjust indentation
                    init_code.append(f"    {line}")
        
        # Combine all parts
        model_code.append(f"class {model_class.__name__}(Pydantic2DjangoBaseClass):")
        model_code.extend(fields)
        model_code.extend(meta_code)
        if init_code:
            model_code.append("")
            model_code.extend(init_code)
        model_code.append("")
    
    # Generate __all__ list
    all_models = [model_class.__name__ for _, model_class in sorted_models]
    all_code = [
        "",
        f"__all__ = {all_models}",
    ]
    
    # Combine all parts
    code = "\n".join(imports + model_code + all_code)
    return code 